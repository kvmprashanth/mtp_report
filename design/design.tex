
\chapter{Design of Empherical Evaluation}

  \section{Experimental Guidelines}
    \label{section_guidelines}
    
    The following are a set of guidelines that any empirical analysis of memory management techniques in a container environment must 
abide by.  All experiments presented in this report were designed and executed around these guidelines.

    \begin{enumerate}
      \item All experiments must comprise of a set of valid configurations that could be readily applied to any container based OS-level 
virtualization environment. These configurations must be readily available, and easy to apply.
      \item Set of workloads used must always be configured in such a way that it is memory intensive, and always throttles only on memory 
and no other resource.
      \item All experiments must be reproducible and statistically correct.      
    \end{enumerate}

  \section{Experimental Configurations}
    
    As pointed out in section \ref{section_guidelines}, the set of configurations used for an analysis of memory management techniques in a 
container environment must be relevant, and easy to apply. The following configurations fit this criteria, and have been used for the 
evaluation.
    
    \begin{itemize}
      \item \textbf{Number of containers:} The number of containers that are currently executing in the system.
      \item \textbf{Memory soft limit of container:} The minimum promised memory to a given container by the system on which the 
container is executing.
      \item \textbf{Memory hard limit of container:} The maximum memory that can be assigned to a container by the system on which the 
container is executing.
      \item \textbf{Memory usage of each container:} The usage of a container at a given point in time, that is generated by the workload 
executing inside the container.
      \item \textbf{Workload:} The workload that is running inside each of the container. Workloads can vary based on the type of operation 
they perform, the ratio of anonymous memory pages they consume to that of page cache pages.  
      \item \textbf{External memory pressure:} The memory pressure that is generated in the system in order to reduce the free memory 
available in the system and trigger memory reclamation. This pressure could be either generated by a process on the same system / driver 
that is running in the host system.
      \item \textbf{Size of machine:} Size of Machine refers to the maximum memory available in the system inside which all the 
containers are executing.      
    \end{itemize}  
    
  \section{Workloads}
  
    This section presents the list of workloads that we have used as primary candidates to evaluate our empirical evaluations. All 
workloads are chosen keeping in mind the memory intensive nature as mentioned in \ref{section_guidelines}.  
    
    \subsection{Synthetic Workloads}
    
      These are the list of Synthetic workloads we have used to establish our problem.
      
      \subsubsection{Stress}
	Stress \cite{stress} is a deliberately simple workload generator for POSIX systems. It imposes a configurable amount of CPU, 
memory, I/O, and disk stress on the system. It is written in C and has been developed by people at Harvard university. 
      
      \subsubsection{Memory Hogger}
	Memory Hogger is a simple C program that allocates an array of specified memory using a simple \texttt{malloc()} and repeatedly 
writes to these array locations. This only consumes anonymous memory pages.
      
      \subsubsection{File Hogger}
	File Hogger is a simple python program that creates a file with specified size and repeatedly updates it line by line there by 
consuming both anonymous pages and file backed pages.

    \subsection{Real Workloads}
    
      These are the list of real workloads we have used to show how the existing problems affect real work applications.
      
      \subsubsection{MongoDB}
	MongoDB \cite{mongodb} is an open-source, document database designed for ease of development and scaling. Classified as a NoSQL 
database program, MongoDB avoids the traditional table-based relational database structure in favor of JSON-like documents with dynamic 
schemas. It follows a memory hungry approach where it tries to use up most of system and it actually leaves it up to the OS's 
VMM to tell it to release the memory.

      \subsubsection{Redis}
	Redis \cite{redis} is a in-memory data structure store, used as database, cache and message broker. It is used to store a large 
number of in-memory key-value pairs. Its in-memory nature makes it a prime candidate to use it as a workload in our empirical evaluations.
   
    \subsection{YCSB Benchmark}
	We use YCSB \cite{cooper2010benchmarking} (Yahoo Cloud Server Benchmark) project as the benchmark to generate the clients evaluate 
to the performance of our real workloads i.e MongoDB and Redis servers. The goal of YSCB is to develop performance comparisons of the new 
generation of cloud data serving systems. It is a framework and common set of workloads for evaluating the performance of different 
“key-value” stores.
	